Our goal regarding BFS was to determine the shortest path spanning trees for our graphs, along with visiting every vertex (User) in our datasets. When researching our datasets, we read that for certain applications, they recommend reversing the direction of the graphs, especially for the reply network dataset, to better illustrate the flow information throughout the graph. Thus, with our vertex hashing table and vertex-key vector we were able to traverse breadth first through our graph, starting with the most recent nodes added based on the ordering of our datasets. This provided us with the opportunity to visit each node from the bottom up, tracing each node to its ancestors in a breadth-first manner. When running “./main”, the BFS traversal will be output to “BFS_Results_Main.txt” for the dataset that “./main” was run with (by default this is the Reply Network.

The goal we set for our Floyd-Warshall Algorithm was to construct a “_n” matrix which served as our “next” matrix. We used this to compress our graph and find a shortest path between any two vertices. We set every node in this graph equal to infinity then we set the weights of all available edges in the intersection of the two vertex numbers in the matrix. Then we went through every node that occurred in the path between every node pair to find if any two edge combinations that went from one node to another were less costly to traverse then the compared one edge. If it was then we put the node in the middle in our “next” matrix. This matrix was then used to calculate our shortest path algorithm which followed this “next” matrix until it reached the destination node. The Floyd-Warshall Algorithm guaranteed that the path we were taking was either already compressed or we had compressed it. Results are outputed to Results_FW.text.

The main goal of our project was to use a Betweenness Centrality algorithm to find the most influential node in our datasets. As our dataset was composed of twitter interactions surrounding the discovery of a particle with the features of Higgs boson, we determined that the most influential user would be a user that is involved in the most reply chains. Because a reply chain can be viewed as bidirectional and is unweighted, we used the [Brandes](www.uvm.edu/pdodds/research/papers/others/2001/brandes2001a.pdf) implementation of Betweenness Centrality to calculate the betweenness score for each node and then returned the node with the highest betweenness score. In the case that two nodes had the same score, we returned a list of all nodes with that score. Because we used Brandes algorithm, our time complexity was reduced from the expected. Results are outputed to Results_BC.text.
